"""
Created on November 27, 2021

@authors: Kevin Huy Nguyen

"""

from spflow.base.memoize import memoize
from spflow.base.structure.nodes.node_module import SumNode, ProductNode, LeafNode
import numpy as np
from numpy import ndarray
from scipy.special import logsumexp  # type: ignore
from spflow.base.structure.network_type import SPN, NetworkType
from spflow.base.structure.nodes.node import (
    ISumNode,
    IProductNode,
    ILeafNode,
)

from .leaves.parametric import node_likelihood, node_log_likelihood
from typing import List, Callable, Type, Dict
from multipledispatch import dispatch  # type: ignore


def prod_log_likelihood(node: IProductNode, children: List[ndarray], **kwargs) -> ndarray:
    """
    Calculates the log-likelihood for a product node.

    Args:
        node:
            IProductNode to calculate log-likelihood for.
        children:
            np.array of child node values of IProductNode.

    Returns: Log-likelihood value for product node.
    """

    llchildren: ndarray = np.concatenate(children, axis=1)
    pll: ndarray = np.sum(llchildren, axis=1).reshape(-1, 1)
    pll[np.isinf(pll)] = np.finfo(pll.dtype).min

    return pll


def prod_likelihood(node: IProductNode, children: List[ndarray], **kwargs) -> ndarray:
    """
    Calculates the likelihood for a product node.

    Args:
        node:
            IProductNode to calculate likelihood for.
        children:
            np.array of child node values of IProductNode.

    Returns: likelihood value for product node.
    """

    llchildren: ndarray = np.concatenate(children, axis=1)

    return np.prod(llchildren, axis=1).reshape(-1, 1)


def sum_log_likelihood(node: ISumNode, children: List[ndarray], **kwargs) -> ndarray:
    """
    Calculates the log-likelihood for a sum node.

    Args:
        node:
            ISumNode to calculate log-likelihood for.
        children:
            np.array of child node values of ISumNode.

    Returns: Log-likelihood value for sum node.
    """

    llchildren: ndarray = np.concatenate(children, axis=1)
    b: ndarray = node.weights
    sll: ndarray = logsumexp(llchildren, b=b, axis=1).reshape(-1, 1)

    return sll


def sum_likelihood(node: ISumNode, children: List[ndarray], **kwargs) -> ndarray:
    """
    Calculates the likelihood for a sum node.

    Args:
        node:
            ISumNode to calculate likelihood for.
        children:
            np.array of child node values of ISumNode.

    Returns: Likelihood value for sum node.
    """

    llchildren: ndarray = np.concatenate(children, axis=1)
    b: ndarray = np.array(node.weights)

    return np.dot(llchildren, b).reshape(-1, 1)


_node_log_likelihood: Dict[Type, Callable] = {
    ISumNode: sum_log_likelihood,
    IProductNode: prod_log_likelihood,
    ILeafNode: node_log_likelihood,
}
_node_likelihood: Dict[Type, Callable] = {
    ISumNode: sum_likelihood,
    IProductNode: prod_likelihood,
    ILeafNode: node_likelihood,
}


@dispatch(SumNode, np.ndarray, SPN, node_log_likelihood_dict=dict, cache=dict)
@memoize(SumNode)
def log_likelihood(
    module: SumNode,
    data: np.ndarray,
    network_type: NetworkType,
    node_log_likelihood_dict=None,
    cache: Dict = {},
) -> np.ndarray:
    """
    Recursively calculates the log_likelihood for a SumNode module.
    It calls log_likelihood on all it children to calculate its own value by using the fitting evaluation function.

    Args:
        module:
            SumNode module to calculate log_likelihood for.
        data:
            Given observed or missing data.
        network_type:
            NetworkType to dispatch to this evaluation method. Expected to be SPN.
        node_log_likelihood_dict:
            Dictionary containing evaluation methods for SPNs.
        cache:
            Dictionary collecting which nodes were already calculated to avoid recalculating them.

    Returns: Log_likelihood value for SumNode module.
    """
    node_log_likelihood_dict = node_log_likelihood_dict or _node_log_likelihood
    inputs = [
        log_likelihood(
            child,
            data,
            child.network_type,
            node_log_likelihood_dict=_node_log_likelihood,
            cache=cache,
        )
        for child in module.children
    ]
    node = module.nodes[0]
    eval_func = node_log_likelihood_dict[type(node)]
    return eval_func(node, inputs)


@dispatch(ProductNode, np.ndarray, SPN, node_log_likelihood_dict=dict, cache=dict)
@memoize(ProductNode)
def log_likelihood(
    module: ProductNode,
    data: np.ndarray,
    network_type: NetworkType,
    node_log_likelihood_dict=None,
    cache: Dict = {},
) -> np.ndarray:
    """
    Recursively calculates the log_likelihood for a ProdNode module.
    It calls log_likelihood on all it children to calculate its own value by using the fitting evaluation function.

    Args:
        module:
            ProdNode module to calculate log_likelihood for.
        data:
            Given observed or missing data.
        network_type:
            NetworkType to dispatch to this evaluation method. Expected to be SPN.
        node_log_likelihood_dict:
            Dictionary containing evaluation methods for SPNs.
        cache:
            Dictionary collecting which nodes were already calculated to avoid recalculating them.

    Returns: Log_likelihood value for ProdNode module.
    """
    node_log_likelihood_dict = node_log_likelihood_dict or _node_log_likelihood
    inputs = [
        log_likelihood(
            child,
            data,
            child.network_type,
            node_log_likelihood_dict=_node_log_likelihood,
            cache=cache,
        )
        for child in module.children
    ]
    node = module.nodes[0]
    eval_func = node_log_likelihood_dict[type(node)]
    return eval_func(node, inputs)


@dispatch(LeafNode, np.ndarray, SPN, node_log_likelihood_dict=dict, cache=dict)
@memoize(LeafNode)
def log_likelihood(
    module: LeafNode,
    data: np.ndarray,
    network_type: NetworkType,
    node_log_likelihood_dict=None,
    cache: Dict = {},
) -> np.ndarray:
    """
    Calculates log_likelihood for a LeafNode module by evaluating the distribution represented by the leaf node type.

    Args:
        module:
            LeafNode module to calculate log_likelihood for.
        data:
            Given observed or missing data.
        network_type:
            NetworkType to dispatch to this evaluation method. Expected to be SPN.
        node_log_likelihood_dict:
            Only used to dispatch to this function.
        cache:
            Dictionary collecting which nodes were already calculated to avoid recalculating them.

    Returns: Log_likelihood value for LeafNode module.
    """
    return node_log_likelihood(module.nodes[0], data=data)


@dispatch(SumNode, np.ndarray, SPN, node_likelihood_dict=dict, cache=dict)
@memoize(SumNode)
def likelihood(
    module: SumNode,
    data: np.ndarray,
    network_type: NetworkType,
    node_likelihood_dict=None,
    cache: Dict = {},
) -> np.ndarray:
    """
    Recursively calculates the likelihood for a SumNode module.
    It calls likelihood on all it children to calculate its own value by using the fitting evaluation function.

    Args:
        module:
            SumNode module to calculate likelihood for.
        data:
            Given observed or missing data.
        network_type:
            NetworkType to dispatch to this evaluation method. Expected to be SPN.
        node_likelihood_dict:
            Dictionary containing evaluation methods for SPNs.
        cache:
            Dictionary collecting which nodes were already calculated to avoid recalculating them.

    Returns: Likelihood value for SumNode module.
    """
    node_likelihood_dict = node_likelihood_dict or _node_likelihood
    inputs = [
        likelihood(
            child, data, child.network_type, node_likelihood_dict=_node_likelihood, cache=cache
        )
        for child in module.children
    ]
    node = module.nodes[0]
    eval_func = node_likelihood_dict[type(node)]
    return eval_func(node, inputs)


@dispatch(ProductNode, np.ndarray, SPN, node_likelihood_dict=dict, cache=dict)
@memoize(ProductNode)
def likelihood(
    module: ProductNode,
    data: np.ndarray,
    network_type: NetworkType,
    node_likelihood_dict=None,
    cache: Dict = {},
) -> np.ndarray:
    """
    Recursively calculates the likelihood for a ProdNode module.
    It calls likelihood on all it children to calculate its own value by using the fitting evaluation function.

    Args:
        module:
            ProdNode module to calculate likelihood for.
        data:
            Given observed or missing data.
        network_type:
            NetworkType to dispatch to this evaluation method. Expected to be SPN.
        node_likelihood_dict:
            Dictionary containing evaluation methods for SPNs.
        cache:
            Dictionary collecting which nodes were already calculated to avoid recalculating them.

    Returns: Likelihood value for ProdNode module.
    """
    node_likelihood_dict = node_likelihood_dict or _node_likelihood
    inputs = [
        likelihood(
            child, data, child.network_type, node_likelihood_dict=_node_likelihood, cache=cache
        )
        for child in module.children
    ]
    node = module.nodes[0]
    eval_func = node_likelihood_dict[type(node)]
    return eval_func(node, inputs)


@dispatch(LeafNode, np.ndarray, SPN, node_log_likelihood_dict=dict, cache=dict)
@memoize(LeafNode)
def likelihood(
    module: LeafNode,
    data: np.ndarray,
    network_type: NetworkType,
    node_likelihood_dict=None,
    cache: Dict = {},
) -> np.ndarray:
    """
    Calculates likelihood for a LeafNode module by evaluating the distribution represented by the leaf node type.

    Args:
        module:
            LeafNode module to calculate likelihood for.
        data:
            Given observed or missing data.
        network_type:
            NetworkType to dispatch to this evaluation method. Expected to be SPN.
        node_likelihood_dict:
            Used to dispatch to this function.
        cache:
            Dictionary collecting which nodes were already calculated to avoid recalculating them.

    Returns: Likelihood value for LeafNode module.
    """
    return node_likelihood(module.nodes[0], data=data)
